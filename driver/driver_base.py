# Copyright (c) 2020 Xilinx, Inc.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# * Redistributions of source code must retain the above copyright notice, this
#   list of conditions and the following disclaimer.
#
# * Redistributions in binary form must reproduce the above copyright notice,
#   this list of conditions and the following disclaimer in the documentation
#   and/or other materials provided with the distribution.
#
# * Neither the name of Xilinx nor the names of its
#   contributors may be used to endorse or promote products derived from
#   this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

import numpy as np
import os
import time
from pynq import Overlay, allocate, GPIO
from pynq.ps import Clocks
from qonnx.core.datatype import DataType
from qonnx.util.basic import gen_finn_dt_tensor

from finn.util.data_packing import (
    finnpy_to_packed_bytearray,
    packed_bytearray_to_finnpy,
)

# Define a function to read specific bit ranges from GPIO
def read_gpio_ranges():
    # Read bits 11:0
    gpio_pins_0_11 = [GPIO(GPIO.get_gpio_pin(i), 'in') for i in range(12)]
    value_0_11 = 0
    for i in range(12):
        bit_value = gpio_pins_0_11[i].read()
        value_0_11 |= (bit_value << i)

    # Read bits 23:12
    gpio_pins_12_23 = [GPIO(GPIO.get_gpio_pin(i), 'in') for i in range(12, 24)]
    value_12_23 = 0
    for i in range(12):
        bit_value = gpio_pins_12_23[i].read()
        value_12_23 |= (bit_value << i)

    # Read bits 29:24
    gpio_pins_24_29 = [GPIO(GPIO.get_gpio_pin(i), 'in') for i in range(24, 30)]
    value_24_29 = 0
    for i in range(6):
        bit_value = gpio_pins_24_29[i].read()
        value_24_29 |= (bit_value << i)

    # Read bits 35:30
    gpio_pins_30_35 = [GPIO(GPIO.get_gpio_pin(i), 'in') for i in range(30, 36)]
    value_30_35 = 0
    for i in range(6):
        bit_value = gpio_pins_30_35[i].read()
        value_30_35 |= (bit_value << i)

    # Return all the values
    return value_0_11, value_12_23, value_24_29, value_30_35

# Driver base class for FINN-generated dataflow accelerators.
# The particulars of the generated accelerator are specified via the
# io_shape_dict (generated by the MakePYNQDriver transformation).


class FINNExampleOverlay(Overlay):
    def __init__(
        self,
        bitfile_name,
        platform,
        io_shape_dict,
        batch_size=1,
        fclk_mhz=100.0,
        device=None,
        download=True,
        runtime_weight_dir="MVAU_weights_npy/",
    ):
        """Initialize the FINN accelerator.

        Parameters
        ----------
        bitfile_name: str
            Path to accelerator .bit/.xclbin file
        platform: str
            FINN platform type, either "alveo" or "zynq-iodma"
        io_shape_dict: dict
            Dictionary with particulars of the generated accelerator
        batch_size: int
            Maximum batch size in driver (hardware batchsize is always 1)
        fclk_mhz: float
            Override the clock frequency, only possible for Zynq.
        device: pynq.Device
            Which PYNQ device to use, None for default.
        download: bool
            Whether to flash the bitstream.
        runtime_weight_dir: str
            Path to runtime weights folder.
        """
        super().__init__(bitfile_name, download=download, device=device)
        self.runtime_weight_dir = runtime_weight_dir
        self._io_shape_dict = io_shape_dict
        self.ibuf_packed_device = None
        self.obuf_packed_device = None
        self.platform = platform
        self.batch_size = batch_size
        self.fclk_mhz = fclk_mhz
        self.idma = []
        self.odma = []
        self.iwdma = []
        self.accel = []
        self.odma_handle = []
        
        if "input_dma_name" in io_shape_dict.keys():
            for idma_name in io_shape_dict["input_dma_name"]:
                self.idma.append(getattr(self, idma_name))
        else:
            self.idma = [self.idma0]
            
        if "output_dma_name" in io_shape_dict.keys():
            for odma_name in io_shape_dict["output_dma_name"]:
                self.odma.append(getattr(self, odma_name))
        else:
            self.odma = [self.odma0]

        if "weight_dma_name" in io_shape_dict.keys():
            for iwdma_name in io_shape_dict["weight_dma_name"]:
                self.iwdma.append(getattr(self, iwdma_name))
        else:
            self.iwdma = [self.iwdma0]

        if "accel_name" in io_shape_dict.keys():
            for accel_name in io_shape_dict["accel_name"]:
                self.accel.append(getattr(self, accel_name))
            
        if self.platform == "zynq-iodma":
            # set the clock frequency as specified by user during transformations
            if self.fclk_mhz > 0:
                Clocks.fclk0_mhz = self.fclk_mhz
        # load any external + runtime weights
        self.load_external_weights()
        # self.load_runtime_weights()
        
    def to_uint4(self, value):
        if value < 0:
            return value + 16
        else:
            return value
        
    def pack_uint4_to_uint8(self, in_array):
        """
        Pack an array of uint4 values (4-bit) into uint8 values (8-bit).

        Parameters:
        shape (tuple): Shape of the input uint4 array. The last dimension should be even, 
                       as it represents two 4-bit values to be packed into one 8-bit value.

        Returns:
        np.ndarray: Packed array of uint8 values.
        """
        shape = in_array.shape

        # Allocate space for the packed data (half the number of elements in the last dimension)
        packed_shape = shape[:-1] + (shape[-1] // 2,)
        out_array = np.zeros(packed_shape, dtype=np.uint8)

        # Iterate and pack two uint4 values into one uint8 value
        for i in range(in_array.shape[0]):
            for j in range(in_array.shape[1]):
                for k in range(0, in_array.shape[2], 2):
                    # Extract two consecutive 4-bit values
                    first_4bit = self.to_uint4(in_array[i, j, k])
                    second_4bit = self.to_uint4(in_array[i, j, k + 1])

                    # Pack the two 4-bit values into one 8-bit value
                    packed_value = second_4bit * 16 + first_4bit

                    # Store the packed value in the output array
                    out_array[i, j, k // 2] = packed_value

        return out_array

    def load_external_weights(self):
        """Load any existing external (DRAM) weights from the specified dir into the
        appropriate layer of the accelerator. Note that this must be enabled
        during the accelerator build process. The weights directory
        is specified as the class member ``runtime_weight_dir``. External (DRAM)
        weights are one .npy file per layer.
        """

        w_filenames = []
        if not os.path.isdir(self.runtime_weight_dir):
            return
        for dirpath, dirnames, filenames in os.walk(self.runtime_weight_dir):
            w_filenames.extend(filenames)
    
        w_filenames = sorted(w_filenames, key=lambda x: int(x.split('_')[1].split('.')[0]))
    
        weight_tensor_dconv = []
        weight_tensor_ups = []
        
        for w_filename in w_filenames:
            if w_filename.endswith(".npy"):
                index = int(w_filename.split('_')[1].split('.')[0])
                weight_tensor = np.load(self.runtime_weight_dir + "/" + w_filename)
                packed_weight_tensor = self.pack_uint4_to_uint8(weight_tensor)
                if index in [6, 9]:
                    weight_tensor_ups.append(packed_weight_tensor)
#                     print("%s : index %d, weight_tensor_shape %s" % (w_filename, index, packed_weight_tensor.shape))
                else:
                    weight_tensor_dconv.append(packed_weight_tensor)
#                     print("%s : index %d, weight_tensor_shape %s" % (w_filename, index, packed_weight_tensor.shape))
            else:
                continue
                

        self.iwbuf_dconv = []
        self.iwbuf_ups = []

        for weight_tensor in weight_tensor_dconv:
            iwbuf = allocate(weight_tensor.shape, dtype=np.uint8)
            iwbuf[:] = weight_tensor
            # flush() ensure that any modifications made to the iwbuf in host memory are written out to device memory 
            # before the device accesses the data
            iwbuf.flush()
            self.iwbuf_dconv.append(iwbuf)

        for weight_tensor in weight_tensor_ups:
            iwbuf = allocate(weight_tensor.shape, dtype=np.uint8)
            iwbuf[:] = weight_tensor
            iwbuf.flush()
            self.iwbuf_ups.append(iwbuf)
            
#         print("size of iwbuf_dconv : %d" % len(self.iwbuf_dconv))
#         print("size of iwbuf_ups : %d" % len(self.iwbuf_ups))
        
#         for i in range(0, len(self.iwbuf_dconv)):
#             print(self.iwbuf_dconv[i].shape[1])
        print("Initialization completes!")
            

    def load_runtime_weights(self, flush_accel=True, verify=True):
        """Load any existing runtime-writable weights from the specified dir into the
        appropriate layer of the accelerator. Note that this must be enabled
        during the accelerator build process. The runtime weights directory
        is specified as the class member ``runtime_weight_dir``. Runtime-writable
        weights are provided as one .dat file per layer.

        Parameters
        ----------
        flush_accel: bool
            Run the accelerator with dummy input after weights are written to
            flush any stale weight data in the weight streamer FIFOs.
        verify: bool
            Whether the written weights will be re-read and verified.
        """
        w_filenames = []
        if not os.path.isdir(self.runtime_weight_dir):
            return
        for dirpath, dirnames, filenames in os.walk(self.runtime_weight_dir):
            w_filenames.extend(filenames)
        rt_weight_dict = {}
        for w_filename in w_filenames:
            if w_filename.endswith(".dat"):
                with open(self.runtime_weight_dir + "/" + w_filename, "r") as f:
                    dat = f.read()
            else:
                continue
            layer_w = np.fromiter([int(x, 16) for x in dat.strip().split()], dtype=np.uint32)
            sdp_ind = int(w_filename.split("_")[0])
            layer_ind = int(w_filename.split("_")[1])
            rt_weight_dict[(sdp_ind, layer_ind)] = layer_w
        for sdp_ind, layer_ind in rt_weight_dict.keys():
            cand_if_name = "StreamingDataflowPartition_%d" % sdp_ind
            if cand_if_name in self.ip_dict.keys():
                layer_mmio = getattr(self, "StreamingDataflowPartition_%d" % sdp_ind).mmio # find the StreamingDataflowPartition_%d ip.mmio
                layer_w = rt_weight_dict[(sdp_ind, layer_ind)]
                layer_mmio.write_mm(0, layer_w.tobytes())
                if verify:
                    new_w = np.copy(layer_mmio.array[: layer_w.shape[0]])
                    assert (layer_w == new_w).all()
        if flush_accel:
            # run accelerator to flush any stale weights from weight streamer FIFOs
            self.execute_on_buffers()

    def idt(self, ind=0):
        return self._io_shape_dict["idt"][ind]

    def odt(self, ind=0):
        return self._io_shape_dict["odt"][ind]

    def ishape_normal(self, ind=0):
        ret = list(self._io_shape_dict["ishape_normal"][ind])
        ret[0] = self.batch_size
        return tuple(ret)

    def oshape_normal(self, ind=0):
        ret = list(self._io_shape_dict["oshape_normal"][ind])
        ret[0] = self.batch_size
        return tuple(ret)

    def ishape_folded(self, ind=0):
        ret = list(self._io_shape_dict["ishape_folded"][ind])
        ret[0] = self.batch_size
        return tuple(ret)

    def oshape_folded(self, ind=0):
        ret = list(self._io_shape_dict["oshape_folded"][ind])
        ret[0] = self.batch_size
        return tuple(ret)

    def ishape_packed(self, ind=0):
        ret = list(self._io_shape_dict["ishape_packed"][ind])
        ret[0] = self.batch_size
        return tuple(ret)

    def oshape_packed(self, ind=0):
        ret = list(self._io_shape_dict["oshape_packed"][ind])
        ret[0] = self.batch_size
        return tuple(ret)

    def block(self, ind=0):
        return self._io_shape_dict["block"][ind]

    def IFMDim_arg(self, ind=0):
        return self._io_shape_dict["IFMDim_arg"][ind]
    
    def OFMDim_arg(self, ind=0):
        return self._io_shape_dict["OFMDim_arg"][ind]
    
    def IFMChannel_arg(self, ind=0):
        return self._io_shape_dict["IFMChannel_arg"][ind]
    
    def MVAU_OFMChannel_arg(self, ind=0):
        return self._io_shape_dict["MVAU_OFMChannel_arg"][ind]
    
    def weight_in_simd_arg(self, ind=0):
        return self._io_shape_dict["weight_in_simd_arg"][ind]
    
    def MVAU_Tiles_arg(self, ind=0):
        return self._io_shape_dict["MVAU_Tiles_arg"][ind]
    
    def UpS_Tiles_arg(self, ind=0):
        return self._io_shape_dict["UpS_Tiles_arg"][ind]
    
    def OUPChannel_arg(self, ind=0):
        return self._io_shape_dict["OUPChannel_arg"][ind]
    
    def nf_compute(self, ind=0):
        return self._io_shape_dict["nf_compute"][ind]

    def scale_factor_arg(self, ind=0):
        return self._io_shape_dict["scale_factor_arg"][ind]

    def Padding_arg(self, ind=0):
        return self._io_shape_dict["Padding_arg"][ind]
    
    def MaxPooling_en(self, ind=0):
        return self._io_shape_dict["MaxPooling_en"][ind]
    
    def Upsampling_en(self, ind=0):
        return self._io_shape_dict["Upsampling_en"][ind]
    
    def buf_index(self, ind=0):
        return self._io_shape_dict["buf_index"][ind]

    @property
    def num_inputs(self):
        return self._io_shape_dict["num_inputs"]

    @property
    def num_outputs(self):
        return self._io_shape_dict["num_outputs"]

    @property
    def batch_size(self):
        return self._batch_size

    @batch_size.setter
    def batch_size(self, value):
        self._batch_size = value
        # free the old buffers by setting to None
        # (reference counting should care of it)
        if self.ibuf_packed_device is not None:
            self.ibuf_packed_device = None
        if self.obuf_packed_device is not None:
            self.obuf_packed_device = None
        cacheable = {"alveo": False, "zynq-iodma": True}[self.platform]
        self.ibuf_packed_device = []
        self.obuf_packed_device = []
        self.obuf_packed = []
        for i in range(self.num_inputs):
            new_packed_ibuf = allocate(
                shape=self.ishape_packed(i), dtype=np.uint8, cacheable=cacheable, target=self.device
            )
            self.ibuf_packed_device.append(new_packed_ibuf)
        for o in range(self.num_outputs):
            new_packed_obuf = allocate(
                shape=self.oshape_packed(o), dtype=np.uint8, cacheable=cacheable, target=self.device
            )
            self.obuf_packed_device.append(new_packed_obuf)
            self.obuf_packed.append(np.empty_like(new_packed_obuf))

    def fold_input(self, ibuf_normal, ind=0):
        """Reshapes input in desired shape.
        Gets input data (ibuf_normal), checks if data is in expected normal shape.
        Returns folded input."""
        # ensure that shape is as expected
        assert ibuf_normal.shape == self.ishape_normal(ind)
        # convert to folded form
        ibuf_folded = ibuf_normal.reshape(self.ishape_folded(ind))
        return ibuf_folded

    def pack_input(self, ibuf_folded, ind=0):
        """Packs folded input and reverses both SIMD dim and endianness.
        Gets input data in folded shape and returns packed input data."""
        ibuf_packed = finnpy_to_packed_bytearray(
            ibuf_folded,
            self.idt(ind),
            reverse_endian=True,
            reverse_inner=True,
            fast_mode=True,
        )
        return ibuf_packed

    def unpack_output(self, obuf_packed, ind=0):
        """Unpacks the packed output buffer from accelerator.
        Gets packed output and returns output data in folded shape."""
        obuf_folded = packed_bytearray_to_finnpy(
            obuf_packed,
            self.odt(ind),
            self.oshape_folded(ind),
            reverse_endian=True,
            reverse_inner=True,
            fast_mode=True,
        )
        return obuf_folded

    def unfold_output(self, obuf_folded, ind=0):
        """Unfolds output data to normal shape.
        Gets folded output data and returns output data in normal shape."""
        obuf_normal = obuf_folded.reshape(self.oshape_normal(ind))
        return obuf_normal

    def copy_input_data_to_device(self, data, ind=0):
        """Copies given input data to PYNQ buffer."""
        np.copyto(self.ibuf_packed_device[ind], data)
        self.ibuf_packed_device[ind].flush()

    def copy_output_data_from_device(self, data, ind=0):
        """Copies PYNQ output buffer from device."""
        self.obuf_packed_device[ind].invalidate()
        np.copyto(data, self.obuf_packed_device[ind])

    def execute_on_buffers(self, asynch=False, batch_size=None):
        """Executes accelerator by setting up the DMA(s) on pre-allocated buffers.
        Blocking behavior depends on the asynch parameter:
        * ``asynch=True`` will block until all transfers are complete.
        * ``asynch=False`` won't block, use ``wait_until_finished()`` to check
           completion

        The optional batch_size parameter can be used to execute on a smaller
        batch than the initialized ``self.batch_size``.
        """
        if batch_size is None:
            batch_size = self.batch_size
        assert batch_size <= self.batch_size, "Specified batch_size is too large."
        if self.platform == "zynq-iodma":
            for o in range(self.num_outputs):
                assert self.odma[o].read(0x00) & 0x4 != 0, "Output DMA %d is not idle" % (o)
            # manually launch IODMAs since signatures are missing
            x = 0
            y = 0
            input_time_accu = 0
            lw_time_accu = 0
            accel_time_accu = 0
            output_time_accu = 0
            
            input_start = time.time()
            for i in range(self.num_inputs):
                self.idma[i].write(0x10, self.ibuf_packed_device[i].device_address)
                self.idma[i].write(0x00, 1)
#                 idma_status = self.idma[i].read(0x00)
#                 while idma_status & 0x2 == 0:
#                     idma_status = self.idma[i].read(0x00)
#                 print("finish idma")
            input_end = time.time()
            input_time_accu += input_end - input_start
                
            for index in range(0, 10):
                lw_start = time.time()
                block_r, is_second_iwdma = self.block(index)
#                 print("running block %d, index %d, x %d" % (block_r, index, x))
                self.iwdma[0].write(0x10, self.iwbuf_dconv[index].device_address)
                self.iwdma[0].write(0x1c, self.iwbuf_dconv[index].shape[1])
                self.iwdma[0].write(0x00, 1)
#                 iwdma0_status = self.iwdma[0].read(0x00)
#                 while iwdma0_status & 0x2 == 0:
#                     iwdma0_status = self.iwdma[0].read(0x00)
                x += 1
#                 print("finish iwdma0")
                if is_second_iwdma:
                    self.iwdma[1].write(0x10, self.iwbuf_ups[y].device_address)
                    self.iwdma[1].write(0x1c, self.iwbuf_ups[y].shape[1])
                    self.iwdma[1].write(0x00, 1)
                    y += 1
#                     iwdma1_status = self.iwdma[1].read(0x00)
#                     while iwdma1_status & 0x2 == 0:
#                         iwdma1_status = self.iwdma[1].read(0x00)
#                     print("finish iwdma1")
                lw_end = time.time()
                lw_time_accu += lw_end - lw_start
        
#                 value_0_11, value_12_23, value_24_29, value_30_35 = read_gpio_ranges()
#                 print(f"Value of bits 11:0: {value_0_11}")
#                 print(f"Value of bits 23:12: {value_12_23}")
#                 print(f"Value of bits 29:24: {value_24_29}")
#                 print(f"Value of bits 35:30: {value_30_35}")
                '''
                print(self.IFMDim_arg(index))
                print(self.OFMDim_arg(index))
                print(self.IFMChannel_arg(index))
                print(self.MVAU_OFMChannel_arg(index))
                print(self.weight_in_simd_arg(index))
                print(self.MVAU_Tiles_arg(index))
                print(self.UpS_Tiles_arg(index))
                print(self.OUPChannel_arg(index))
                print(self.nf_compute(index))
                print(self.scale_factor_arg(index))
                print(self.Padding_arg(index))
                print(self.MaxPooling_en(index))
                print(self.Upsampling_en(index))
                print(self.buf_index(index))
                '''
                accel_start = time.time()
                self.accel[0].write(0x10, block_r)
#                 self.accel[0].write(0x18, self.IFMDim_arg(index))
#                 self.accel[0].write(0x20, self.OFMDim_arg(index))
#                 self.accel[0].write(0x28, self.IFMChannel_arg(index))
#                 self.accel[0].write(0x30, self.MVAU_OFMChannel_arg(index))
#                 self.accel[0].write(0x38, self.weight_in_simd_arg(index))
#                 self.accel[0].write(0x40, self.MVAU_Tiles_arg(index))
#                 self.accel[0].write(0x48, self.UpS_Tiles_arg(index))
#                 self.accel[0].write(0x50, self.OUPChannel_arg(index))
#                 self.accel[0].write(0x58, self.nf_compute(index))
#                 self.accel[0].write(0x60, self.scale_factor_arg(index))
#                 self.accel[0].write(0x68, self.Padding_arg(index))
#                 self.accel[0].write(0x70, self.MaxPooling_en(index))
#                 self.accel[0].write(0x78, self.Upsampling_en(index))
#                 self.accel[0].write(0x80, self.buf_index(index))
                self.accel[0].write(0x00, 1)
#                 accel_start = time.time()
                status = self.accel[0].read(0x00)
                while status & 0x2 == 0:
                    status = self.accel[0].read(0x00)
#                 print("finish block %d" % (block_r))
                accel_end = time.time()
                accel_time_accu += accel_end - accel_start
                
#                 value_0_11, value_12_23, value_24_29, value_30_35 = read_gpio_ranges()
#                 print(f"Value of bits 11:0: {value_0_11}")
#                 print(f"Value of bits 23:12: {value_12_23}")
#                 print(f"Value of bits 29:24: {value_24_29}")
#                 print(f"Value of bits 35:30: {value_30_35}")

            output_start = time.time()
            for o in range(self.num_outputs):
                self.odma[o].write(0x10, self.obuf_packed_device[o].device_address)
                self.odma[o].write(0x00, 1)
                odma_status = self.odma[o].read(0x00)
                while odma_status & 0x2 == 0:
                    odma_status = self.odma[o].read(0x00)
            output_end = time.time()
            output_time_accu += output_end - output_start
#                 print("finish odma")
            #for i in range(self.num_inputs):
            #    self.idma[i].write(0x10, self.ibuf_packed_device[i].device_address)
            #    self.idma[i].write(0x00, 1)
        else:
            raise Exception("Unrecognized platform: %s" % self.platform)
            
        total_time = input_time_accu + lw_time_accu + accel_time_accu + output_time_accu
        print("input_time_accu = ", input_time_accu * 1000)
        print("lw_time_accu = ", lw_time_accu * 1000)
        print("accel_time_accu = ", accel_time_accu * 1000)
        print("output_time_accu = ", output_time_accu * 1000)
        print("total_time = ", total_time * 1000)

    def wait_until_finished(self):
        "Block until all output DMAs have finished writing."
        if self.platform == "zynq-iodma":
            # check if output IODMA is finished via register reads
            for o in range(self.num_outputs):
                # We check if bit 1(AP_DONE) is 1, if so, it means the accel finishes its job.
                # Otherwise, we should wait until it finishes.
                status = self.odma[o].read(0x00)
                while status & 0x2 == 0:
                    status = self.odma[o].read(0x00)
        else:
            raise Exception("Unrecognized platform: %s" % self.platform)

    def execute(self, input_npy): # this is input data, not weight
        """Given a single or a list of input numpy array, 
        1. perform necessary packing
        2. copy to device buffers
        3. execute on accelerator
        4. unpack output
        5. return output numpy array from accelerator."""
        # if single input, convert to list to normalize how we process the input
        if not type(input_npy) is list:
            input_npy = [input_npy]
        assert self.num_inputs == len(input_npy), "Not all accelerator inputs are specified."
        
        # load all inputs
        for i in range(self.num_inputs):
            ibuf_folded = self.fold_input(input_npy[i], ind=i)
            ibuf_packed = self.pack_input(ibuf_folded, ind=i)
            self.copy_input_data_to_device(ibuf_packed, ind=i)
            
        # start accel and wait until it finished
        self.execute_on_buffers()
        self.wait_until_finished()
        
        outputs = []
        for o in range(self.num_outputs):
            self.copy_output_data_from_device(self.obuf_packed[o], ind=o)
            obuf_folded = self.unpack_output(self.obuf_packed[o], ind=o)
            obuf_normal = self.unfold_output(obuf_folded, ind=o)
            outputs.append(obuf_normal)
        if self.num_outputs == 1:
            return outputs[0]
        else:
            return outputs

